## 1.Objective
μ΄ μμ μ λ©μ μ€ FreeRTOSμ—μ„ νλ¥Ό ν†µν•΄ ν¬μΈν„°λ¥Ό μ•μ „ν•κ² μ „λ‹¬ν•λ” λ°©λ²•μ„ μ‹¤μµν•λ” κ²ƒμ…λ‹λ‹¤.
ν¬μΈν„° μμ²΄λ¥Ό μ „λ‹¬ν•¨μΌλ΅μ¨ λ¬Έμμ—΄ λλ” κµ¬μ΅°μ²΄ κ°™μ€ ν° λ°μ΄ν„°λ¥Ό λ³µμ‚¬ν•μ§€ μ•κ³ , ν¨μ¨μ μΌλ΅ νƒμ¤ν¬ κ°„ ν†µμ‹ μ„ μν–‰ν•©λ‹λ‹¤.

## 2.λ™μ‘ μ‹λ‚λ¦¬μ¤
π§Ύ PlantUML μ‹ν€€μ¤ λ‹¤μ΄μ–΄κ·Έλ¨

```plantuml
@startuml
participant SenderTask
participant Queue
participant ReceiverTask

loop Every 100ms
    SenderTask -> SenderTask: pvPortMalloc(50)
    SenderTask -> SenderTask: snprintf()λ΅ λ¬Έμμ—΄ μ‘μ„±
    SenderTask -> Queue: xQueueSendToBack(ν¬μΈν„°)
    ReceiverTask -> Queue: xQueueReceive(ν¬μΈν„° μμ‹ )
    ReceiverTask -> ReceiverTask: UARTλ΅ λ¬Έμμ—΄ μ¶λ ¥
    ReceiverTask -> ReceiverTask: vPortFree()λ΅ λ©”λ¨λ¦¬ ν•΄μ 
end
@enduml
```
## 3.μ£Όμ” ν•¨μ μ„¤λ…
π”Ή SenderTask
```c
pcToSendStirng  = (char *)pvPortMalloc(50);
snprintf(pcToSendStirng, 50, "Hello from SenderTask %d\r\n", sendIndex++);
xQueueSendToBack(xQueue, &pcToSendStirng, portMAX_DELAY);
pvPortMalloc()μΌλ΅ λ™μ  λ©”λ¨λ¦¬ ν™•λ³΄ (50 bytes)
snprintf()λ΅ λ¬Έμμ—΄ μƒμ„±
```
ν¬μΈν„°λ§ νμ— μ „μ†΅ β†’ λ¬Έμμ—΄ μ „μ²΄λ¥Ό λ³µμ‚¬ν•μ§€ μ•μ•„ μ¤λ²„ν—¤λ“ κ°μ†

π”Ή ReceiverTask
```c
void ReceiverTask(void *pvParameters) {
    char * pcReceivingString;
    while (1) {
        if (xQueueReceive(xQueue, &pcReceivingString, portMAX_DELAY) == pdPASS) {   
            vPortFree(pcReceivingString); // Free the buffer after use
        } 
    }
}
```
νμ—μ„ ν¬μΈν„° μμ‹ 
λ¬Έμμ—΄ μ‚¬μ© ν›„ λ°λ“μ‹ vPortFree()λ΅ ν•΄μ 
β†’ ν•΄μ ν•μ§€ μ•μΌλ©΄ Memory Leak λ°μƒ

## 4.Expected Output
μ‹λ¦¬μ–Ό ν„°λ―Έλ„μ—μ„ λ‹¤μκ³Ό κ°™μ€ μ¶λ ¥μ΄ λ°λ³µλ¨:

```log
Hello from SenderTask 0
Hello from SenderTask 1
Hello from SenderTask 2
```

## 5.νμ‰ν¬μΈν„° vs κΈ°μ΅΄ λ°©μ‹
νμ‰ν¬μΈν„°  μ„±λ¥ μ¤λ²„ν—¤λ“	λ†’μ	λ‚®μ ( )
λ©”λ¨λ¦¬ κ΄€λ¦¬	μλ™	μμ‹  μΈ΅μ—μ„ ν•΄μ  ν•„μ”

> π”ΉλΉ„μ 
> κΈ°μ΅΄ λ°©μ‹: νΈμ§€λ¥Ό λ³µμ‚¬ν•΄μ„ μ°μ²΄κµ­(ν)μ— λ„£λ” κ²ƒ
> λ³µμ‚¬λ³Έμ΄ λ§μΌλ©΄ λ¬΄κ²κ³  λλ ¤μ”
> ν¬μΈν„° λ°©μ‹: νΈμ§€λ¥Ό κ°€λ¦¬ν‚¤λ” μ£Όμ† λ©”λ¨λ§ λ³΄λ‚΄λ” κ²ƒ
> β†’ μ°μ²΄κµ­μ—μ„λ” μ£Όμ†λ§ λ°›κ³ , μμ‹ μκ°€ ν•΄λ‹Ή μ£Όμ†λ΅ μ§μ ‘ μ°Ύμ•„κ°€μ„ μ—΄μ–΄λ³΄κ³ , μ½κ³  λ‚μ„ νκΈ°

β• μ¶”κ°€ ν™•μ¥
ν¬μΈν„°μ μ£Όμ† μμ²΄λ¥Ό λ νμ— λ³΄λ‚Ό μ μμ β†’ "μ£Όμ†μ μ£Όμ†"
μ΄λ” μ΄μ¤‘ ν¬μΈν„° char **λ΅ ν‘ν„λ¨ (ex. μ΄μ¤‘ κµ¬μ΅°μ²΄ κ΄€λ¦¬ λ“±)

β οΈ μ£Όμμ‚¬ν•­
λ©”λ¨λ¦¬ μ†μ κ¶(Ownership): ν• λ‹Ήκ³Ό ν•΄μ μ μ±…μ„ λ¶„λ…ν ν• λ‹Ή
Senderκ°€ malloc, Receiverκ°€ free
λ©”λ¨λ¦¬ λ„μ(Memory Leak): vPortFree() μƒλµ μ‹ λ°μƒ
λ•κΈ€λ§ ν¬μΈν„°(Dangling Pointer): ν•΄μ  ν›„ μ ‘κ·Ό κΈμ§€

β… κ²°λ΅ 
FreeRTOSμ—μ„ ν¬μΈν„° κΈ°λ° ν μ „μ†΅μ΄ μ„±λ¥μ„ μ–΄λ–»κ² ν–¥μƒμ‹ν‚¤λ”μ§€λ¥Ό μ• μ μμµλ‹λ‹¤.
λ‹¨, μ •ν™•ν• λ©”λ¨λ¦¬ κ΄€λ¦¬κ°€ ν•„μμ΄λ©°, ν¬μΈν„° μ „λ‹¬μ€ ν•­μƒ μ±…μ„ μλ” ν•΄μ κ°€ λ’¤λ”°λΌμ•Ό ν•¨.