# `preemption.c` 튜토리얼

이 문서는 `preemption.c` 예제 코드의 목적, 동작 방식 및 예상 결과에 대해 설명합니다.

## 1. Objective (목표)

이 예제의 주요 목표는 FreeRTOS에서 **선점형(Preemptive)** 스케줄링을 시연하는 것입니다. 선점형 스케줄링에서는 더 높은 우선순위를 가진 태스크가 준비(Ready) 상태가 되면, 현재 실행 중인 낮은 우선순위의 태스크를 즉시 중단시키고 CPU 제어권을 가져옵니다. 이 예제에서는 우선순위가 다른 두 개의 태스크를 생성하여 이 동작을 확인합니다.

## 2. Code Description (코드 설명)

- **`Task1(void *pvParameters)` (우선순위: 2 - 높음)**
  - `main` 함수에서 전달받은 문자열 (`"Task1 HI\r\n"`)을 시리얼 포트(UART3)로 출력합니다.
  - 파란색 LED (LD1)를 1초 동안 켋니다.
  - 3초의 초기 딜레이 후, 1초마다 반복 실행됩니다.

- **`Task2(void *pvParameters)` (우선순위: 1 - 낮음)**
  - `main` 함수에서 전달받은 문자열 (`"Task2 LI\r\n"`)을 시리얼 포트(UART3)로 출력합니다.
  - 초록색 LED (LD2)를 토글(Toggle)합니다.
  - 1초마다 반복 실행됩니다.

- **`main(void)`**
  - `Driver_Init()`를 호출하여 MCU의 하드웨어를 초기화합니다.
  - `xTaskCreate` 함수를 사용하여 `Task1`과 `Task2`를 생성합니다. `Task1`은 우선순위 `2`, `Task2`는 우선순위 `1`로 설정하여 `Task1`이 더 높은 우선순위를 갖도록 합니다.
  - `vTaskStartScheduler()`를 호출하여 FreeRTOS 스케줄러를 시작합니다.

## 3. Expected Output (예상 결과)

코드가 실행되면 스케줄러는 다음과 같이 동작합니다.

1.  **초기 3초:** `Task1`은 3초 동안 대기 상태에 있으므로, 우선순위가 낮은 `Task2`가 실행됩니다. `Task2`는 1초마다 초록색 LED를 토글하고 `Task2 LI` 메시지를 출력합니다.
2.  **3초 후:** `Task1`의 대기가 끝나고 준비 상태가 됩니다. `Task1`은 `Task2`보다 우선순위가 높기 때문에, 스케줄러는 즉시 `Task2`의 실행을 중단하고 `Task1`을 실행합니다.
3.  **`Task1` 실행:** `Task1`은 파란색 LED를 켜고 `Task1 HI` 메시지를 출력한 후, 1초 동안 대기합니다.
4.  **`Task1` 대기:** `Task1`이 대기 상태에 들어가면, 다시 우선순위가 가장 높은 준비 상태의 태스크인 `Task2`가 실행을 재개합니다.

이 과정이 반복되면서 다음과 같은 결과를 확인할 수 있습니다.

### 3.1. 시리얼 출력 (Serial Output)

시리얼 터미널에서는 `Task2`의 메시지가 출력되다가, 3초 후부터는 `Task1`의 메시지가 주기적으로 `Task2`의 실행을 중단시키고 출력되는 것을 볼 수 있습니다.

```
Task2 LI
Task2 LI
Task2 LI
Task1 HI
Task2 LI
Task1 HI
Task2 LI
Task1 HI
...
```

### 3.2. LED 동작 (LED Behavior)

- **초록색 LED (LD2):** 계속해서 1초 주기로 깜빡입니다. 하지만 `Task1`이 실행되는 동안에는 `Task2`가 멈추기 때문에 깜빡임이 약간씩 지연될 수 있습니다.
- **파란색 LED (LD1):** 3초 후부터 1초 동안 켜졌다가 꺼지는 동작을 반복합니다.