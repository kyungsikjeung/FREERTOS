<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTOS: C:/Users/TOVIS/test/TestRtos/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_hash.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTOS<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_60925fc218da8ca7908795bf5f624060.html">Drivers</a></li><li class="navelem"><a href="dir_0f7073d6b1d1d49104212e142cbd4b45.html">STM32F4xx_HAL_Driver</a></li><li class="navelem"><a href="dir_30168dac808c8ac2b97106172ddd8c3b.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="headertitle"><div class="title">stm32f4xx_hal_hash.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>HASH HAL module driver. This file provides firmware functions to manage the following functionalities of the HASH peripheral:  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="stm32f4xx__hal_8h_source.html">stm32f4xx_hal.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for stm32f4xx_hal_hash.c:</div>
<div class="dyncontent">
<div class="center"><img src="stm32f4xx__hal__hash_8c__incl.png" border="0" usemap="#a_c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_drivers_2_s_t_m32_f4xx___h_a_l___driver_2_src_2stm32f4xx__hal__hash_8c" loading="lazy" alt=""/></div>
<map name="a_c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_drivers_2_s_t_m32_f4xx___h_a_l___driver_2_src_2stm32f4xx__hal__hash_8c" id="a_c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_drivers_2_s_t_m32_f4xx___h_a_l___driver_2_src_2stm32f4xx__hal__hash_8c">
<area shape="rect" title="HASH HAL module driver. This file provides firmware functions to manage the following functionalities..." alt="" coords="1323,5,1523,80"/>
<area shape="rect" href="stm32f4xx__hal_8h.html" title="This file contains all the functions prototypes for the HAL module driver." alt="" coords="1364,128,1482,155"/>
<area shape="poly" title=" " alt="" coords="1426,80,1426,112,1420,112,1420,80"/>
<area shape="rect" href="stm32f4xx__hal__conf_8h.html" title=" " alt="" coords="1348,203,1498,229"/>
<area shape="poly" title=" " alt="" coords="1426,155,1426,187,1420,187,1420,155"/>
<area shape="rect" href="stm32f4xx__hal__rcc_8h.html" title="Header file of RCC HAL module." alt="" coords="1269,277,1411,304"/>
<area shape="poly" title=" " alt="" coords="1410,232,1368,269,1364,265,1407,228"/>
<area shape="rect" href="stm32f4xx__hal__gpio_8h.html" title="Header file of GPIO HAL module." alt="" coords="1898,277,2046,304"/>
<area shape="poly" title=" " alt="" coords="1499,225,1883,275,1883,280,1498,230"/>
<area shape="rect" href="stm32f4xx__hal__exti_8h.html" title="Header file of EXTI HAL module." alt="" coords="2070,277,2216,304"/>
<area shape="poly" title=" " alt="" coords="1498,221,1742,242,2055,274,2054,280,1741,247,1498,226"/>
<area shape="rect" href="stm32f4xx__hal__dma_8h.html" title="Header file of DMA HAL module." alt="" coords="1096,277,1246,304"/>
<area shape="poly" title=" " alt="" coords="1380,232,1230,275,1229,270,1378,227"/>
<area shape="rect" href="stm32f4xx__hal__cortex_8h.html" title="Header file of CORTEX HAL module." alt="" coords="2240,277,2400,304"/>
<area shape="poly" title=" " alt="" coords="1498,219,1811,239,2225,274,2224,280,1810,245,1498,224"/>
<area shape="rect" href="stm32f4xx__hal__adc_8h.html" title="Header file containing functions prototypes of ADC HAL library." alt="" coords="20,277,165,304"/>
<area shape="poly" title=" " alt="" coords="1348,223,884,245,248,280,181,285,180,280,248,275,884,239,1348,218"/>
<area shape="rect" href="stm32f4xx__hal__eth_8h.html" title="Header file of ETH HAL module." alt="" coords="260,277,402,304"/>
<area shape="poly" title=" " alt="" coords="1348,224,483,280,418,285,418,280,483,275,1348,219"/>
<area shape="rect" href="stm32f4xx__hal__flash_8h.html" title="Header file of FLASH HAL module." alt="" coords="495,277,647,304"/>
<area shape="poly" title=" " alt="" coords="1348,226,663,284,662,279,1348,221"/>
<area shape="rect" href="stm32f4xx__hal__pwr_8h.html" title="Header file of PWR HAL module." alt="" coords="784,277,929,304"/>
<area shape="poly" title=" " alt="" coords="1348,230,945,281,944,275,1347,224"/>
<area shape="rect" href="stm32f4xx__hal__tim_8h.html" title="Header file of TIM HAL module." alt="" coords="1436,277,1578,304"/>
<area shape="poly" title=" " alt="" coords="1439,228,1483,265,1479,269,1436,232"/>
<area shape="rect" href="stm32f4xx__hal__uart_8h.html" title="Header file of UART HAL module." alt="" coords="1683,360,1829,387"/>
<area shape="poly" title=" " alt="" coords="1465,227,1525,248,1591,275,1664,313,1725,349,1723,354,1661,317,1589,280,1523,253,1463,233"/>
<area shape="rect" href="stm32f4xx__hal__pcd_8h.html" title="Header file of PCD HAL module." alt="" coords="1710,277,1856,304"/>
<area shape="poly" title=" " alt="" coords="1487,227,1706,271,1705,276,1486,233"/>
<area shape="rect" href="stm32f4xx__hal__def_8h.html" title="This file contains HAL common defines, enumeration, macros and structures definitions." alt="" coords="1125,443,1267,469"/>
<area shape="poly" title=" " alt="" coords="1314,307,1281,327,1249,354,1224,391,1207,429,1203,427,1219,389,1245,350,1278,322,1312,302"/>
<area shape="rect" href="stm32f4xx__hal__rcc__ex_8h.html" title="Header file of RCC HAL Extension module." alt="" coords="1259,360,1422,387"/>
<area shape="poly" title=" " alt="" coords="1343,304,1343,345,1338,345,1338,304"/>
<area shape="rect" href="stm32f4xx_8h.html" title="CMSIS STM32F4xx Device Peripheral Access Layer Header File." alt="" coords="914,517,1007,544"/>
<area shape="poly" title=" " alt="" coords="1156,472,1017,515,1015,510,1154,467"/>
<area shape="rect" href="stm32__hal__legacy_8h.html" title="This file contains aliases definition for the STM32Cube HAL constants macros and functions maintained..." alt="" coords="1030,517,1213,544"/>
<area shape="poly" title=" " alt="" coords="1185,472,1147,509,1143,505,1181,468"/>
<area shape="rect" title=" " alt="" coords="1237,517,1305,544"/>
<area shape="poly" title=" " alt="" coords="1211,468,1249,505,1246,509,1207,472"/>
<area shape="poly" title=" " alt="" coords="1319,389,1233,437,1230,433,1317,385"/>
<area shape="poly" title=" " alt="" coords="1984,303,1997,323,2008,347,2011,373,2008,385,2001,397,1986,406,1963,415,1895,428,1804,439,1697,446,1471,455,1283,457,1283,452,1471,450,1697,441,1803,433,1894,423,1962,409,1984,401,1997,393,2003,383,2006,373,2002,349,1992,325,1980,306"/>
<area shape="rect" href="stm32f4xx__hal__gpio__ex_8h.html" title="Header file of GPIO HAL Extension module." alt="" coords="2062,360,2232,387"/>
<area shape="poly" title=" " alt="" coords="2001,302,2107,351,2105,356,1998,307"/>
<area shape="poly" title=" " alt="" coords="2088,390,2043,397,1830,421,1617,437,1283,455,1283,449,1617,432,1829,415,2043,392,2087,385"/>
<area shape="poly" title=" " alt="" coords="2184,302,2219,321,2234,334,2247,351,2255,374,2254,385,2246,397,2232,404,2204,410,2115,420,1843,437,1532,449,1283,456,1283,450,1532,444,1843,432,2114,415,2203,404,2230,398,2243,393,2249,384,2250,375,2242,353,2230,338,2216,325,2182,307"/>
<area shape="poly" title=" " alt="" coords="1176,304,1195,427,1189,428,1170,305"/>
<area shape="rect" href="stm32f4xx__hal__dma__ex_8h.html" title="Header file of DMA HAL extension module." alt="" coords="963,360,1133,387"/>
<area shape="poly" title=" " alt="" coords="1153,307,1081,354,1078,349,1150,302"/>
<area shape="poly" title=" " alt="" coords="1073,385,1161,433,1159,437,1070,390"/>
<area shape="poly" title=" " alt="" coords="2320,305,2305,351,2290,377,2268,397,2246,407,2212,415,2113,429,1983,439,1835,447,1527,455,1283,457,1283,452,1527,450,1835,442,1983,434,2112,424,2211,410,2244,402,2266,392,2286,373,2300,349,2315,304"/>
<area shape="poly" title=" " alt="" coords="83,306,69,325,56,349,51,373,53,383,59,393,75,399,109,405,219,416,542,430,1039,440,1110,445,1110,450,1039,445,542,435,219,421,108,411,74,404,56,397,48,385,46,373,51,347,64,322,79,303"/>
<area shape="rect" href="stm32f4xx__ll__adc_8h.html" title="Header file of ADC LL module." alt="" coords="893,443,1027,469"/>
<area shape="poly" title=" " alt="" coords="67,307,38,326,26,339,16,353,8,375,9,384,15,393,51,403,130,413,372,430,878,450,877,455,372,436,129,419,49,408,12,397,4,385,3,374,11,351,22,335,35,322,64,302"/>
<area shape="rect" href="stm32f4xx__hal__adc__ex_8h.html" title="Header file of ADC HAL module." alt="" coords="69,360,235,387"/>
<area shape="poly" title=" " alt="" coords="104,303,136,346,132,349,100,306"/>
<area shape="poly" title=" " alt="" coords="963,470,963,502,958,502,958,470"/>
<area shape="poly" title=" " alt="" coords="210,385,254,392,474,415,646,424,818,429,1039,440,1110,445,1110,450,1039,445,818,434,645,429,473,420,253,397,209,390"/>
<area shape="poly" title=" " alt="" coords="329,305,320,348,322,372,333,393,348,402,374,410,454,423,558,431,676,435,1039,440,1110,445,1110,451,1039,445,676,441,558,436,453,428,373,416,346,407,329,396,317,374,315,348,324,304"/>
<area shape="poly" title=" " alt="" coords="495,304,431,316,373,336,353,347,341,361,340,376,350,393,365,402,391,410,468,422,570,430,685,435,1039,440,1110,445,1110,451,1039,445,684,440,570,436,467,428,389,415,363,407,346,397,335,377,336,359,350,343,371,331,429,311,494,299"/>
<area shape="rect" href="stm32f4xx__hal__flash__ex_8h.html" title="Header file of FLASH HAL Extension module." alt="" coords="360,360,534,387"/>
<area shape="poly" title=" " alt="" coords="553,307,480,354,477,349,550,302"/>
<area shape="rect" href="stm32f4xx__hal__flash__ramfunc_8h.html" title="Header file of FLASH RAMFUNC driver." alt="" coords="558,352,699,395"/>
<area shape="poly" title=" " alt="" coords="582,303,607,338,603,341,578,306"/>
<area shape="poly" title=" " alt="" coords="504,385,546,392,811,420,1110,445,1109,450,810,425,545,397,503,390"/>
<area shape="poly" title=" " alt="" coords="822,307,789,325,775,338,764,353,756,374,758,383,763,393,804,404,894,417,1110,443,1109,448,893,423,803,409,760,397,753,385,751,374,759,351,771,335,786,321,819,302"/>
<area shape="rect" href="stm32f4xx__hal__pwr__ex_8h.html" title="Header file of PWR HAL Extension module." alt="" coords="773,360,939,387"/>
<area shape="poly" title=" " alt="" coords="859,304,859,345,854,345,854,304"/>
<area shape="poly" title=" " alt="" coords="910,385,1128,436,1127,441,909,390"/>
<area shape="poly" title=" " alt="" coords="1504,306,1479,351,1459,376,1435,397,1399,417,1360,432,1284,450,1283,445,1359,427,1397,412,1432,392,1455,372,1474,348,1499,303"/>
<area shape="rect" href="stm32f4xx__hal__tim__ex_8h.html" title="Header file of TIM HAL Extended module." alt="" coords="1496,360,1659,387"/>
<area shape="poly" title=" " alt="" coords="1520,303,1559,347,1555,351,1516,306"/>
<area shape="poly" title=" " alt="" coords="1518,390,1272,442,1271,436,1517,385"/>
<area shape="poly" title=" " alt="" coords="1707,390,1671,397,1462,429,1283,449,1282,444,1462,423,1671,392,1706,385"/>
<area shape="rect" href="stm32f4xx__ll__usb_8h.html" title="Header file of USB Low Layer HAL module." alt="" coords="1853,360,1987,387"/>
<area shape="poly" title=" " alt="" coords="1806,302,1887,350,1884,354,1803,307"/>
<area shape="poly" title=" " alt="" coords="1876,390,1842,397,1689,420,1535,436,1283,454,1283,448,1534,431,1688,414,1841,392,1875,385"/>
</map>
</div>
</div>
<p><a href="stm32f4xx__hal__hash_8c_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>HASH HAL module driver. This file provides firmware functions to manage the following functionalities of the HASH peripheral: </p>
<dl class="section author"><dt>Author</dt><dd>MCD Application Team<ul>
<li>Initialization and de-initialization methods</li>
<li>HASH or HMAC processing in polling mode</li>
<li>HASH or HMAC processing in interrupt mode</li>
<li>HASH or HMAC processing in DMA mode</li>
<li>Peripheral State methods</li>
<li>HASH or HMAC processing suspension/resumption</li>
</ul>
</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>Copyright (c) 2016 STMicroelectronics. All rights reserved.</p>
<p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS.</p>
<pre class="fragment">===============================================================================
                    ##### How to use this driver #####
===============================================================================
   [..]
   The HASH HAL driver can be used as follows:

   (#)Initialize the HASH low level resources by implementing the HAL_HASH_MspInit():
       (##) Enable the HASH interface clock using __HASH_CLK_ENABLE()
       (##) When resorting to interrupt-based APIs (e.g. HAL_HASH_xxx_Start_IT())
           (+++) Configure the HASH interrupt priority using HAL_NVIC_SetPriority()
           (+++) Enable the HASH IRQ handler using HAL_NVIC_EnableIRQ()
           (+++) In HASH IRQ handler, call HAL_HASH_IRQHandler() API
       (##) When resorting to DMA-based APIs  (e.g. HAL_HASH_xxx_Start_DMA())
           (+++) Enable the DMAx interface clock using
                  __DMAx_CLK_ENABLE()
           (+++) Configure and enable one DMA stream to manage data transfer from
               memory to peripheral (input stream). Managing data transfer from
               peripheral to memory can be performed only using CPU.
           (+++) Associate the initialized DMA handle to the HASH DMA handle
               using  __HAL_LINKDMA()
           (+++) Configure the priority and enable the NVIC for the transfer complete
               interrupt on the DMA stream: use
                HAL_NVIC_SetPriority() and
                HAL_NVIC_EnableIRQ()

   (#)Initialize the HASH HAL using HAL_HASH_Init(). This function:
       (##) resorts to HAL_HASH_MspInit() for low-level initialization,
       (##) configures the data type: 1-bit, 8-bit, 16-bit or 32-bit.

   (#)Three processing schemes are available:
       (##) Polling mode: processing APIs are blocking functions
            i.e. they process the data and wait till the digest computation is finished,
            e.g. HAL_HASH_xxx_Start() for HASH or HAL_HMAC_xxx_Start() for HMAC
       (##) Interrupt mode: processing APIs are not blocking functions
               i.e. they process the data under interrupt,
               e.g. HAL_HASH_xxx_Start_IT() for HASH or HAL_HMAC_xxx_Start_IT() for HMAC
       (##) DMA mode: processing APIs are not blocking functions and the CPU is
            not used for data transfer i.e. the data transfer is ensured by DMA,
               e.g. HAL_HASH_xxx_Start_DMA() for HASH or HAL_HMAC_xxx_Start_DMA()
               for HMAC. Note that in DMA mode, a call to HAL_HASH_xxx_Finish()
               is then required to retrieve the digest.

   (#)When the processing function is called after HAL_HASH_Init(), the HASH peripheral is
      initialized and processes the buffer fed in input. When the input data have all been
      fed to the Peripheral, the digest computation can start.

   (#)Multi-buffer processing is possible in polling, interrupt and DMA modes.
       (##) In polling mode, only multi-buffer HASH processing is possible.
            API HAL_HASH_xxx_Accumulate() must be called for each input buffer, except for the last one.
            User must resort to HAL_HASH_xxx_Accumulate_End() to enter the last one and retrieve as
            well the computed digest.

       (##) In interrupt mode, API HAL_HASH_xxx_Accumulate_IT() must be called for each input buffer,
            except for the last one.
            User must resort to HAL_HASH_xxx_Accumulate_End_IT() to enter the last one and retrieve as
            well the computed digest.

       (##) In DMA mode, multi-buffer HASH and HMAC processing are possible.
             (+++) HASH processing: once initialization is done, MDMAT bit must be set
              through __HAL_HASH_SET_MDMAT() macro.
            From that point, each buffer can be fed to the Peripheral through HAL_HASH_xxx_Start_DMA() API.
            Before entering the last buffer, reset the MDMAT bit with __HAL_HASH_RESET_MDMAT()
            macro then wrap-up the HASH processing in feeding the last input buffer through the
            same API HAL_HASH_xxx_Start_DMA(). The digest can then be retrieved with a call to
            API HAL_HASH_xxx_Finish().
            (+++) HMAC processing (requires to resort to extended functions):
            after initialization, the key and the first input buffer are entered
            in the Peripheral with the API HAL_HMACEx_xxx_Step1_2_DMA(). This carries out HMAC step 1 and
            starts step 2.
            The following buffers are next entered with the API  HAL_HMACEx_xxx_Step2_DMA(). At this
            point, the HMAC processing is still carrying out step 2.
            Then, step 2 for the last input buffer and step 3 are carried out by a single call
            to HAL_HMACEx_xxx_Step2_3_DMA().

            The digest can finally be retrieved with a call to API HAL_HASH_xxx_Finish().


   (#)Context swapping.
       (##) Two APIs are available to suspend HASH or HMAC processing:
            (+++) HAL_HASH_SwFeed_ProcessSuspend() when data are entered by software (polling or IT mode),
            (+++) HAL_HASH_DMAFeed_ProcessSuspend() when data are entered by DMA.

       (##) When HASH or HMAC processing is suspended, HAL_HASH_ContextSaving() allows
           to save in memory the Peripheral context. This context can be restored afterwards
           to resume the HASH processing thanks to HAL_HASH_ContextRestoring().

       (##) Once the HASH Peripheral has been restored to the same configuration as that at suspension
            time, processing can be restarted with the same API call (same API, same handle,
            same parameters) as done before the suspension. Relevant parameters to restart at
            the proper location are internally saved in the HASH handle.

   (#)Call HAL_HASH_DeInit() to deinitialize the HASH peripheral.

    *** Remarks on message length ***
    ===================================
    [..]
     (#) HAL in interruption mode (interruptions driven)

       (##)Due to HASH peripheral hardware design, the peripheral interruption is triggered every 64 bytes.
       This is why, for driver implementation simplicity s sake, user is requested to enter a message the
       length of which is a multiple of 4 bytes.

       (##) When the message length (in bytes) is not a multiple of words, a specific field exists in HASH_STR
       to specify which bits to discard at the end of the complete message to process only the message bits
       and not extra bits.

       (##) If user needs to perform a hash computation of a large input buffer that is spread around various places
       in memory and where each piece of this input buffer is not necessarily a multiple of 4 bytes in size, it becomes
       necessary to use a temporary buffer to format the data accordingly before feeding them to the Peripheral.
       It is advised to the user to
      (+++) achieve the first formatting operation by software then enter the data
      (+++) while the Peripheral is processing the first input set, carry out the second formatting
       operation by software, to be ready when DINIS occurs.
      (+++) repeat step 2 until the whole message is processed.

    [..]
     (#) HAL in DMA mode

       (##) Again, due to hardware design, the DMA transfer to feed the data can only be done on a word-basis.
       The same field described above in HASH_STR is used to specify which bits to discard at the end of the
       DMA transfer to process only the message bits and not extra bits. Due to hardware implementation,
       this is possible only at the end of the complete message. When several DMA transfers are needed to
       enter the message, this is not applicable at the end of the intermediary transfers.

       (##) Similarly to the interruption-driven mode, it is suggested to the user to format the consecutive
       chunks of data by software while the DMA transfer and processing is on-going for the first parts of
       the message. Due to the 32-bit alignment required for the DMA transfer, it is underlined that the
       software formatting operation is more complex than in the IT mode.

    *** Callback registration ***
    ===================================
    [..]
     (#) The compilation define  USE_HAL_HASH_REGISTER_CALLBACKS when set to 1
         allows the user to configure dynamically the driver callbacks.
         Use function HAL_HASH_RegisterCallback() to register a user callback.

     (#) Function HAL_HASH_RegisterCallback() allows to register following callbacks:
           (+) InCpltCallback    : callback for input completion.
           (+) DgstCpltCallback  : callback for digest computation completion.
           (+) ErrorCallback     : callback for error.
           (+) MspInitCallback   : HASH MspInit.
           (+) MspDeInitCallback : HASH MspDeInit.
         This function takes as parameters the HAL peripheral handle, the Callback ID
         and a pointer to the user callback function.

     (#) Use function HAL_HASH_UnRegisterCallback() to reset a callback to the default
         weak (surcharged) function.
         HAL_HASH_UnRegisterCallback() takes as parameters the HAL peripheral handle,
         and the Callback ID.
         This function allows to reset following callbacks:
           (+) InCpltCallback    : callback for input completion.
           (+) DgstCpltCallback  : callback for digest computation completion.
           (+) ErrorCallback     : callback for error.
           (+) MspInitCallback   : HASH MspInit.
           (+) MspDeInitCallback : HASH MspDeInit.

     (#) By default, after the HAL_HASH_Init and if the state is HAL_HASH_STATE_RESET
         all callbacks are reset to the corresponding legacy weak (surcharged) functions:
         examples HAL_HASH_InCpltCallback(), HAL_HASH_DgstCpltCallback()
         Exception done for MspInit and MspDeInit callbacks that are respectively
         reset to the legacy weak (surcharged) functions in the HAL_HASH_Init
         and HAL_HASH_DeInit only when these callbacks are null (not registered beforehand)
         If not, MspInit or MspDeInit are not null, the HAL_HASH_Init and HAL_HASH_DeInit
         keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

         Callbacks can be registered/unregistered in READY state only.
         Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
         in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
         during the Init/DeInit.
         In that case first register the MspInit/MspDeInit user callbacks
         using HAL_HASH_RegisterCallback before calling HAL_HASH_DeInit
         or HAL_HASH_Init function.

         When The compilation define USE_HAL_HASH_REGISTER_CALLBACKS is set to 0 or
         not defined, the callback registering feature is not available
         and weak (surcharged) callbacks are used.
</pre> 
<p class="definition">Definition in file <a class="el" href="stm32f4xx__hal__hash_8c_source.html">stm32f4xx_hal_hash.c</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
