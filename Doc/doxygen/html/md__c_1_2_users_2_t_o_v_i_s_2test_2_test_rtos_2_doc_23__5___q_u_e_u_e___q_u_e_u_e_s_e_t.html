<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTOS: &lt;tt&gt;queueset.c&lt;/tt&gt; 튜토리얼</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTOS<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title"><span class="tt">queueset.c</span> 튜토리얼 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md102"></a></p>
<p>이 문서는 <span class="tt">queueset.c</span> 예제 코드의 목적, 동작 방식 및 예상 결과에 대해 설명합니다.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
1. Objective (목표)</h1>
<p>이 예제의 주요 목표는 FreeRTOS의 <span class="tt">큐 세트(Queue Set)</span>를 사용하여 여러 큐로부터 들어오는 데이터를 단일 태스크에서 효율적으로 처리하는 방법을 시연하는 것입니다. 큐 세트를 사용하면, 수신 태스크는 어떤 큐에 데이터가 도착했는지 일일이 확인할 필요 없이, 여러 큐 중 하나라도 데이터가 수신되기를 기다릴 수 있습니다.</p>
<p>이 예제에서는 두 개의 송신 태스크가 각각 다른 큐에 메시지를 보내고, 하나의 수신 태스크가 큐 세트를 통해 두 큐 중 어느 곳에서든 데이터가 오기를 기다렸다가 처리하는 과정을 보여줍니다.</p>
<div class="fragment"><div class="line">@startuml</div>
<div class="line">|main()|</div>
<div class="line">start</div>
<div class="line">:Driver_Init();</div>
<div class="line">:create xQueue1;</div>
<div class="line">:create xQueue2;</div>
<div class="line">:create xQueueSet;</div>
<div class="line">:add xQueue1 to xQueueSet;</div>
<div class="line">:add xQueue2 to xQueueSet;</div>
<div class="line">:create vSenderTask1;</div>
<div class="line">:create vSenderTask2;</div>
<div class="line">:create vReceiverTask;</div>
<div class="line">:vTaskStartScheduler();</div>
<div class="line">stop</div>
<div class="line"> </div>
<div class="line">|vSenderTask1()|</div>
<div class="line">start</div>
<div class="line">repeat</div>
<div class="line">  :delay(100ms);</div>
<div class="line">  :Send &quot;Message from vSenderTask1&quot;\nto xQueue1;</div>
<div class="line">repeat while (true)</div>
<div class="line">stop</div>
<div class="line"> </div>
<div class="line">|vSenderTask2()|</div>
<div class="line">start</div>
<div class="line">repeat</div>
<div class="line">  :delay(100ms);</div>
<div class="line">  :Send &quot;test hello world&quot;\nto xQueue2;</div>
<div class="line">repeat while (true)</div>
<div class="line">stop</div>
<div class="line"> </div>
<div class="line">|vReceiverTask()|</div>
<div class="line">start</div>
<div class="line">repeat</div>
<div class="line">  :xQueueSelectFromSet(xQueueSet);</div>
<div class="line">  :xQueueReceive(from selected queue);</div>
<div class="line">  :printf(received message);</div>
<div class="line">repeat while (true)</div>
<div class="line">stop</div>
<div class="line">@enduml</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
2. Code Description (코드 설명)</h1>
<ul>
<li><b><span class="tt"><a class="el" href="3__5__queue__queueset_8c.html#ad64210183d03331fa1828720ea871e1d">vSenderTask1(void *pvParameters)</a></span></b><ul>
<li>100ms마다 <span class="tt">xQueue1</span>에 <span class="tt">"Message from vSenderTask1\r\n"</span>이라는 문자열의 포인터를 보냅니다.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="3__5__queue__queueset_8c.html#af162fe554d482efa17622261646ee8d1">vSenderTask2(void *pvParameters)</a></span></b><ul>
<li>100ms마다 <span class="tt">xQueue2</span>에 <span class="tt">"test hello world\r\n"</span>이라는 문자열의 포인터를 보냅니다.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="3__5__queue__queueset_8c.html#a365255f27e73e0893b7886f57d45844a">vReceiverTask(void *pvParameters)</a></span></b><ul>
<li><span class="tt"><a class="el" href="queue_8h.html#a71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a></span> 함수를 사용하여 큐 세트(<span class="tt">xQueueSet</span>)에 포함된 큐 중 하나라도 데이터가 수신될 때까지 무한정 대기(<span class="tt">portMAX_DELAY</span>)합니다.</li>
<li>데이터가 수신되면, <span class="tt"><a class="el" href="queue_8h.html#a71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a></span>은 데이터가 포함된 큐의 핸들(<span class="tt">xQueueThatContainsData</span>)을 반환합니다.</li>
<li>반환된 큐 핸들을 사용하여 <span class="tt"><a class="el" href="queue_8h.html#ae8364d988c6f9b63c771cc2b3dfe5df9">xQueueReceive()</a></span>를 호출하고, 해당 큐로부터 메시지 포인터를 읽어옵니다.</li>
<li>수신된 문자열을 시리얼 포트로 출력합니다.</li>
</ul>
</li>
<li><b><span class="tt"><a class="el" href="1__1__task__simpletask_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main(void)</a></span></b><ul>
<li><span class="tt"><a class="el" href="driver__init_8h.html#aab7f079e70f08c868bbb3fdd41b86f82" title="Custom driver initialization entry point.">Driver_Init()</a></span>를 호출하여 MCU의 하드웨어를 초기화합니다.</li>
<li><span class="tt">xQueueCreate()</span>를 사용하여 <span class="tt">xQueue1</span>과 <span class="tt">xQueue2</span>를 각각 크기 1로 생성합니다. 각 큐는 문자열 포인터(<span class="tt">char *</span>)를 저장합니다.</li>
<li><span class="tt"><a class="el" href="queue_8h.html#ad4208ad97f737af942a13e64b45e83e8">xQueueCreateSet()</a></span>를 사용하여 두 개의 큐를 담을 수 있는 큐 세트(<span class="tt">xQueueSet</span>)를 생성합니다.</li>
<li><span class="tt"><a class="el" href="queue_8h.html#ae07b563e6bbe42a977f7c46853aa11eb">xQueueAddToSet()</a></span>를 호출하여 <span class="tt">xQueue1</span>과 <span class="tt">xQueue2</span>를 <span class="tt">xQueueSet</span>에 추가합니다.</li>
<li><span class="tt">xTaskCreate</span> 함수를 사용하여 <span class="tt">Sender1</span>, <span class="tt">Sender2</span>, <span class="tt">Receiver</span> 태스크를 생성합니다.<ul>
<li><span class="tt">Sender1</span>, <span class="tt">Sender2</span> 우선순위: 1</li>
<li><span class="tt">Receiver</span> 우선순위: 2 (더 높음)</li>
</ul>
</li>
<li><span class="tt"><a class="el" href="task_8h.html#aaf9dca1065c60abdeb309d56ab7293cb">vTaskStartScheduler()</a></span>를 호출하여 FreeRTOS 스케줄러를 시작합니다.</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
3. Expected Output (예상 결과)</h1>
<p>코드가 실행되면, <span class="tt">Sender1</span>과 <span class="tt">Sender2</span> 태스크는 각각 100ms마다 자신의 큐에 메시지를 보냅니다. <span class="tt">Receiver</span> 태스크는 우선순위가 더 높지만, 큐 세트에 데이터가 도착할 때까지 대기 상태에 있습니다. <span class="tt">Sender</span> 태스크 중 하나가 큐에 데이터를 보내면, <span class="tt">Receiver</span> 태스크가 즉시 활성화되어 해당 데이터를 처리하고 출력합니다.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
3.1. 시리얼 출력 (Serial Output)</h2>
<p>시리얼 터미널에는 두 <span class="tt">Sender</span> 태스크가 보내는 메시지가 번갈아 가며 출력됩니다. 두 태스크의 지연 시간이 같으므로, 스케줄링에 따라 거의 교대로 출력됩니다.</p>
<div class="fragment"><div class="line">Message from vSenderTask1</div>
<div class="line"> </div>
<div class="line">test hello world</div>
<div class="line"> </div>
<div class="line">Message from vSenderTask1</div>
<div class="line"> </div>
<div class="line">test hello world</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
4. Queue Set 동작 방식</h1>
<ol type="1">
<li><b>초기 상태</b>: <span class="tt">Receiver</span> 태스크는 우선순위가 가장 높지만, <span class="tt"><a class="el" href="queue_8h.html#a71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a></span>에서 큐 세트가 비어있어 대기(Blocked) 상태가 됩니다.</li>
<li><b>데이터 전송</b>: <span class="tt">Sender1</span>과 <span class="tt">Sender2</span>는 우선순위가 같으므로 번갈아 실행됩니다. 예를 들어 <span class="tt">Sender1</span>이 먼저 실행되어 <span class="tt">xQueue1</span>에 메시지를 보냅니다.</li>
<li><b>큐 세트 활성화</b>: <span class="tt">xQueue1</span>에 데이터가 들어오면, 이 큐가 속한 <span class="tt">xQueueSet</span>이 활성화됩니다. 이로 인해 대기 중이던 <span class="tt">Receiver</span> 태스크가 준비(Ready) 상태가 됩니다.</li>
<li><b>데이터 수신</b>: <span class="tt">Receiver</span>는 우선순위가 가장 높으므로 즉시 실행됩니다. <span class="tt"><a class="el" href="queue_8h.html#a71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a></span>은 데이터가 있는 <span class="tt">xQueue1</span>의 핸들을 반환하고, <span class="tt">Receiver</span>는 이 핸들을 사용해 데이터를 읽고 출력합니다.</li>
<li><b>반복</b>: <span class="tt">Receiver</span>가 다시 <span class="tt"><a class="el" href="queue_8h.html#a71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a></span>에서 대기 상태로 돌아가면, 다른 <span class="tt">Sender</span> 태스크(<span class="tt">Sender2</span>)가 <span class="tt">xQueue2</span>에 데이터를 보냅니다. 이 과정이 계속 반복됩니다.</li>
</ol>
<p>큐 세트는 여러 이벤트 소스(이 경우, 여러 큐)를 동시에 기다려야 할 때 매우 유용한 동기화 메커니즘입니다. 이를 통해 복잡한 <span class="tt">if-else</span>나 폴링(polling) 로직 없이도 코드를 깔끔하고 효율적으로 작성할 수 있습니다.</p>
<p>``` </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
