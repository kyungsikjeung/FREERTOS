\doxysection{x\+Queue\+Receive\+From\+ISR }
\hypertarget{group__x_queue_receive_from_i_s_r}{}\label{group__x_queue_receive_from_i_s_r}\index{xQueueReceiveFromISR@{xQueueReceiveFromISR}}
queue. h 
\begin{DoxyPre}
\doxylink{portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} \doxylink{queue_8h_acdf528f5c91131ae2f31c669cfd65758}{xQueueReceiveFromISR(                                    QueueHandle\_t    xQueue,                                    void *pvBuffer,                                    BaseType\_t *pxTaskWoken                                )};
  \end{DoxyPre}


Receive an item from a queue. It is safe to use this function from within an interrupt service routine.


\begin{DoxyParams}{Parameters}
{\em x\+Queue} & The handle to the queue from which the item is to be received.\\
\hline
{\em pv\+Buffer} & Pointer to the buffer into which the received item will be copied.\\
\hline
{\em px\+Task\+Woken} & A task may be blocked waiting for space to become available on the queue. If x\+Queue\+Receive\+From\+ISR causes such a task to unblock \texorpdfstring{$\ast$}{*}px\+Task\+Woken will get set to pd\+TRUE, otherwise \texorpdfstring{$\ast$}{*}px\+Task\+Woken will remain unchanged.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pd\+TRUE if an item was successfully received from the queue, otherwise pd\+FALSE.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}

\doxylink{queue_8h_a57349603001f8ddf51c888c49e2804d7}{QueueHandle\_t} xQueue;

// Function to create a queue and post some values.
void vAFunction( void *pvParameters )
\{
char cValueToPost;
const \doxylink{portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} xTicksToWait = ( \doxylink{portmacro_8h_aa69c48c6e902ce54f70886e6573c92a9}{TickType\_t} )0xff;

   // Create a queue capable of containing 10 characters.
   xQueue = xQueueCreate( 10, sizeof( char ) );
   if( xQueue == 0 )
   \{
    // Failed to create the queue.
   \}

   // ...

   // Post some characters that will be used within an ISR.  If the queue
   // is full then this task will block for xTicksToWait ticks.
   cValueToPost = 'a';
   \doxylink{queue_8h_af7eb49d3249351176992950d9185abe9}{xQueueSend( xQueue, ( void * ) \&cValueToPost, xTicksToWait )};
   cValueToPost = 'b';
   \doxylink{queue_8h_af7eb49d3249351176992950d9185abe9}{xQueueSend( xQueue, ( void * ) \&cValueToPost, xTicksToWait )};

   // ... keep posting characters ... this task may block when the queue
   // becomes full.

   cValueToPost = 'c';
   \doxylink{queue_8h_af7eb49d3249351176992950d9185abe9}{xQueueSend( xQueue, ( void * ) \&cValueToPost, xTicksToWait )};
\}

// ISR that outputs all the characters received on the queue.
void vISR\_Routine( void )
\{
\doxylink{portmacro_8h_a46fb21e00ae0729d7515c0fbf2269796}{BaseType\_t} xTaskWokenByReceive = pdFALSE;
char cRxedChar;

   while( xQueueReceiveFromISR( xQueue, ( void * ) \&cRxedChar, \&xTaskWokenByReceive) )
   \{
    // A character was received.  Output the character now.
    vOutputCharacter( cRxedChar );

    // If removing the character from the queue woke the task that was
    // posting onto the queue cTaskWokenByReceive will have been set to
    // pdTRUE.  No matter how many times this loop iterates only one
    // task will be woken.
   \}

   if( cTaskWokenByPost != ( char ) pdFALSE;
   \{
    taskYIELD ();
   \}
\}
\end{DoxyPre}
 