\chapter{{\ttfamily queueset.\+c} 튜토리얼 }
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t}{}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t}\index{$<$tt$>$queueset.c$<$/tt$>$ 튜토리얼@{$<$tt$>$queueset.c$<$/tt$>$ 튜토리얼}}
\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md102}%
\Hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md102}%


이 문서는 {\ttfamily queueset.\+c} 예제 코드의 목적, 동작 방식 및 예상 결과에 대해 설명합니다.\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md103}{}\doxysection{\texorpdfstring{1. Objective (목표)}{1. Objective (목표)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md103}
이 예제의 주요 목표는 Free\+RTOS의 {\ttfamily 큐 세트(\+Queue Set)}를 사용하여 여러 큐로부터 들어오는 데이터를 단일 태스크에서 효율적으로 처리하는 방법을 시연하는 것입니다. 큐 세트를 사용하면, 수신 태스크는 어떤 큐에 데이터가 도착했는지 일일이 확인할 필요 없이, 여러 큐 중 하나라도 데이터가 수신되기를 기다릴 수 있습니다.

이 예제에서는 두 개의 송신 태스크가 각각 다른 큐에 메시지를 보내고, 하나의 수신 태스크가 큐 세트를 통해 두 큐 중 어느 곳에서든 데이터가 오기를 기다렸다가 처리하는 과정을 보여줍니다.


\begin{DoxyCode}{0}
\DoxyCodeLine{@startuml}
\DoxyCodeLine{|main()|}
\DoxyCodeLine{start}
\DoxyCodeLine{:Driver\_Init();}
\DoxyCodeLine{:create\ xQueue1;}
\DoxyCodeLine{:create\ xQueue2;}
\DoxyCodeLine{:create\ xQueueSet;}
\DoxyCodeLine{:add\ xQueue1\ to\ xQueueSet;}
\DoxyCodeLine{:add\ xQueue2\ to\ xQueueSet;}
\DoxyCodeLine{:create\ vSenderTask1;}
\DoxyCodeLine{:create\ vSenderTask2;}
\DoxyCodeLine{:create\ vReceiverTask;}
\DoxyCodeLine{:vTaskStartScheduler();}
\DoxyCodeLine{stop}
\DoxyCodeLine{}
\DoxyCodeLine{|vSenderTask1()|}
\DoxyCodeLine{start}
\DoxyCodeLine{repeat}
\DoxyCodeLine{\ \ :delay(100ms);}
\DoxyCodeLine{\ \ :Send\ "{}Message\ from\ vSenderTask1"{}\(\backslash\)nto\ xQueue1;}
\DoxyCodeLine{repeat\ while\ (true)}
\DoxyCodeLine{stop}
\DoxyCodeLine{}
\DoxyCodeLine{|vSenderTask2()|}
\DoxyCodeLine{start}
\DoxyCodeLine{repeat}
\DoxyCodeLine{\ \ :delay(100ms);}
\DoxyCodeLine{\ \ :Send\ "{}test\ hello\ world"{}\(\backslash\)nto\ xQueue2;}
\DoxyCodeLine{repeat\ while\ (true)}
\DoxyCodeLine{stop}
\DoxyCodeLine{}
\DoxyCodeLine{|vReceiverTask()|}
\DoxyCodeLine{start}
\DoxyCodeLine{repeat}
\DoxyCodeLine{\ \ :xQueueSelectFromSet(xQueueSet);}
\DoxyCodeLine{\ \ :xQueueReceive(from\ selected\ queue);}
\DoxyCodeLine{\ \ :printf(received\ message);}
\DoxyCodeLine{repeat\ while\ (true)}
\DoxyCodeLine{stop}
\DoxyCodeLine{@enduml}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md104}{}\doxysection{\texorpdfstring{2. Code Description (코드 설명)}{2. Code Description (코드 설명)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md104}

\begin{DoxyItemize}
\item {\bfseries{{\ttfamily \doxylink{3__5__queue__queueset_8c_ad64210183d03331fa1828720ea871e1d}{v\+Sender\+Task1(void \texorpdfstring{$\ast$}{*}pv\+Parameters)}}}}
\begin{DoxyItemize}
\item 100ms마다 {\ttfamily x\+Queue1}에 {\ttfamily "{}\+Message from v\+Sender\+Task1\textbackslash{}r\textbackslash{}n"{}}이라는 문자열의 포인터를 보냅니다.
\end{DoxyItemize}
\item {\bfseries{{\ttfamily \doxylink{3__5__queue__queueset_8c_af162fe554d482efa17622261646ee8d1}{v\+Sender\+Task2(void \texorpdfstring{$\ast$}{*}pv\+Parameters)}}}}
\begin{DoxyItemize}
\item 100ms마다 {\ttfamily x\+Queue2}에 {\ttfamily "{}test hello world\textbackslash{}r\textbackslash{}n"{}}이라는 문자열의 포인터를 보냅니다.
\end{DoxyItemize}
\item {\bfseries{{\ttfamily \doxylink{3__5__queue__queueset_8c_a365255f27e73e0893b7886f57d45844a}{v\+Receiver\+Task(void \texorpdfstring{$\ast$}{*}pv\+Parameters)}}}}
\begin{DoxyItemize}
\item {\ttfamily \doxylink{queue_8h_a71f56e6277ed4e419c707c8d0c785065}{x\+Queue\+Select\+From\+Set()}} 함수를 사용하여 큐 세트({\ttfamily x\+Queue\+Set})에 포함된 큐 중 하나라도 데이터가 수신될 때까지 무한정 대기({\ttfamily port\+MAX\+\_\+\+DELAY})합니다.
\item 데이터가 수신되면, {\ttfamily \doxylink{queue_8h_a71f56e6277ed4e419c707c8d0c785065}{x\+Queue\+Select\+From\+Set()}}은 데이터가 포함된 큐의 핸들({\ttfamily x\+Queue\+That\+Contains\+Data})을 반환합니다.
\item 반환된 큐 핸들을 사용하여 {\ttfamily \doxylink{queue_8h_ae8364d988c6f9b63c771cc2b3dfe5df9}{x\+Queue\+Receive()}}를 호출하고, 해당 큐로부터 메시지 포인터를 읽어옵니다.
\item 수신된 문자열을 시리얼 포트로 출력합니다.
\end{DoxyItemize}
\item {\bfseries{{\ttfamily \doxylink{1__1__task__simpletask_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}{main(void)}}}}
\begin{DoxyItemize}
\item {\ttfamily \doxylink{driver__init_8h_aab7f079e70f08c868bbb3fdd41b86f82}{Driver\+\_\+\+Init()}}를 호출하여 MCU의 하드웨어를 초기화합니다.
\item {\ttfamily x\+Queue\+Create()}를 사용하여 {\ttfamily x\+Queue1}과 {\ttfamily x\+Queue2}를 각각 크기 1로 생성합니다. 각 큐는 문자열 포인터({\ttfamily char \texorpdfstring{$\ast$}{*}})를 저장합니다.
\item {\ttfamily \doxylink{queue_8h_ad4208ad97f737af942a13e64b45e83e8}{x\+Queue\+Create\+Set()}}를 사용하여 두 개의 큐를 담을 수 있는 큐 세트({\ttfamily x\+Queue\+Set})를 생성합니다.
\item {\ttfamily \doxylink{queue_8h_ae07b563e6bbe42a977f7c46853aa11eb}{x\+Queue\+Add\+To\+Set()}}를 호출하여 {\ttfamily x\+Queue1}과 {\ttfamily x\+Queue2}를 {\ttfamily x\+Queue\+Set}에 추가합니다.
\item {\ttfamily x\+Task\+Create} 함수를 사용하여 {\ttfamily Sender1}, {\ttfamily Sender2}, {\ttfamily Receiver} 태스크를 생성합니다.
\begin{DoxyItemize}
\item {\ttfamily Sender1}, {\ttfamily Sender2} 우선순위\+: 1
\item {\ttfamily Receiver} 우선순위\+: 2 (더 높음)
\end{DoxyItemize}
\item {\ttfamily \doxylink{task_8h_aaf9dca1065c60abdeb309d56ab7293cb}{v\+Task\+Start\+Scheduler()}}를 호출하여 Free\+RTOS 스케줄러를 시작합니다.
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md105}{}\doxysection{\texorpdfstring{3. Expected Output (예상 결과)}{3. Expected Output (예상 결과)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md105}
코드가 실행되면, {\ttfamily Sender1}과 {\ttfamily Sender2} 태스크는 각각 100ms마다 자신의 큐에 메시지를 보냅니다. {\ttfamily Receiver} 태스크는 우선순위가 더 높지만, 큐 세트에 데이터가 도착할 때까지 대기 상태에 있습니다. {\ttfamily Sender} 태스크 중 하나가 큐에 데이터를 보내면, {\ttfamily Receiver} 태스크가 즉시 활성화되어 해당 데이터를 처리하고 출력합니다.\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md106}{}\doxysubsection{\texorpdfstring{3.\+1. 시리얼 출력 (Serial Output)}{3.\+1. 시리얼 출력 (Serial Output)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md106}
시리얼 터미널에는 두 {\ttfamily Sender} 태스크가 보내는 메시지가 번갈아 가며 출력됩니다. 두 태스크의 지연 시간이 같으므로, 스케줄링에 따라 거의 교대로 출력됩니다.


\begin{DoxyCode}{0}
\DoxyCodeLine{Message\ from\ vSenderTask1}
\DoxyCodeLine{}
\DoxyCodeLine{test\ hello\ world}
\DoxyCodeLine{}
\DoxyCodeLine{Message\ from\ vSenderTask1}
\DoxyCodeLine{}
\DoxyCodeLine{test\ hello\ world}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md107}{}\doxysection{\texorpdfstring{4. Queue Set 동작 방식}{4. Queue Set 동작 방식}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__5___q_u_e_u_e___q_u_e_u_e_s_e_t_autotoc_md107}

\begin{DoxyEnumerate}
\item {\bfseries{초기 상태}}\+: {\ttfamily Receiver} 태스크는 우선순위가 가장 높지만, {\ttfamily \doxylink{queue_8h_a71f56e6277ed4e419c707c8d0c785065}{x\+Queue\+Select\+From\+Set()}}에서 큐 세트가 비어있어 대기(\+Blocked) 상태가 됩니다.
\item {\bfseries{데이터 전송}}\+: {\ttfamily Sender1}과 {\ttfamily Sender2}는 우선순위가 같으므로 번갈아 실행됩니다. 예를 들어 {\ttfamily Sender1}이 먼저 실행되어 {\ttfamily x\+Queue1}에 메시지를 보냅니다.
\item {\bfseries{큐 세트 활성화}}\+: {\ttfamily x\+Queue1}에 데이터가 들어오면, 이 큐가 속한 {\ttfamily x\+Queue\+Set}이 활성화됩니다. 이로 인해 대기 중이던 {\ttfamily Receiver} 태스크가 준비(\+Ready) 상태가 됩니다.
\item {\bfseries{데이터 수신}}\+: {\ttfamily Receiver}는 우선순위가 가장 높으므로 즉시 실행됩니다. {\ttfamily \doxylink{queue_8h_a71f56e6277ed4e419c707c8d0c785065}{x\+Queue\+Select\+From\+Set()}}은 데이터가 있는 {\ttfamily x\+Queue1}의 핸들을 반환하고, {\ttfamily Receiver}는 이 핸들을 사용해 데이터를 읽고 출력합니다.
\item {\bfseries{반복}}\+: {\ttfamily Receiver}가 다시 {\ttfamily \doxylink{queue_8h_a71f56e6277ed4e419c707c8d0c785065}{x\+Queue\+Select\+From\+Set()}}에서 대기 상태로 돌아가면, 다른 {\ttfamily Sender} 태스크({\ttfamily Sender2})가 {\ttfamily x\+Queue2}에 데이터를 보냅니다. 이 과정이 계속 반복됩니다.
\end{DoxyEnumerate}

큐 세트는 여러 이벤트 소스(이 경우, 여러 큐)를 동시에 기다려야 할 때 매우 유용한 동기화 메커니즘입니다. 이를 통해 복잡한 {\ttfamily if-\/else}나 폴링(polling) 로직 없이도 코드를 깔끔하고 효율적으로 작성할 수 있습니다.

\`{}\`{}\`{} 