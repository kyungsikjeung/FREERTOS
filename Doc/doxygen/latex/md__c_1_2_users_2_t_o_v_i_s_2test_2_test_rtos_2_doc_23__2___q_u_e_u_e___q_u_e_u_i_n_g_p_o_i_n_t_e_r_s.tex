\chapter{1.\+Objective }
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s}{}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s}\index{1.Objective@{1.Objective}}
\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md77}%
\Hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md77}%


이 예제의 목적은 Free\+RTOS에서 큐를 통해 포인터를 안전하게 전달하는 방법을 실습하는 것입니다. 포인터 자체를 전달함으로써 문자열 또는 구조체 같은 큰 데이터를 복사하지 않고, 효율적으로 태스크 간 통신을 수행합니다.\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md78}{}\doxysection{\texorpdfstring{2.동작 시나리오}{2.동작 시나리오}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md78}
🧾 Plant\+UML 시퀀스 다이어그램


\begin{DoxyCode}{0}
\DoxyCodeLine{@startuml}
\DoxyCodeLine{participant\ SenderTask}
\DoxyCodeLine{participant\ Queue}
\DoxyCodeLine{participant\ ReceiverTask}
\DoxyCodeLine{}
\DoxyCodeLine{loop\ Every\ 100ms}
\DoxyCodeLine{\ \ \ \ SenderTask\ -\/>\ SenderTask:\ pvPortMalloc(50)}
\DoxyCodeLine{\ \ \ \ SenderTask\ -\/>\ SenderTask:\ snprintf()로\ 문자열\ 작성}
\DoxyCodeLine{\ \ \ \ SenderTask\ -\/>\ Queue:\ xQueueSendToBack(포인터)}
\DoxyCodeLine{\ \ \ \ ReceiverTask\ -\/>\ Queue:\ xQueueReceive(포인터\ 수신)}
\DoxyCodeLine{\ \ \ \ ReceiverTask\ -\/>\ ReceiverTask:\ UART로\ 문자열\ 출력}
\DoxyCodeLine{\ \ \ \ ReceiverTask\ -\/>\ ReceiverTask:\ vPortFree()로\ 메모리\ 해제}
\DoxyCodeLine{end}
\DoxyCodeLine{@enduml}

\end{DoxyCode}
 \hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md79}{}\doxysection{\texorpdfstring{3.주요 함수 설명}{3.주요 함수 설명}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md79}
🔹 Sender\+Task 
\begin{DoxyCode}{0}
\DoxyCodeLine{pcToSendStirng\ \ =\ (\textcolor{keywordtype}{char}\ *)\mbox{\hyperlink{portable_8h_a7aaf584d8f548d7f03d6a46280c9e877}{pvPortMalloc}}(50);}
\DoxyCodeLine{snprintf(pcToSendStirng,\ 50,\ \textcolor{stringliteral}{"{}Hello\ from\ SenderTask\ \%d\(\backslash\)r\(\backslash\)n"{}},\ sendIndex++);}
\DoxyCodeLine{\mbox{\hyperlink{queue_8h_a81d24a2c1199d58efb76fbee15853112}{xQueueSendToBack}}(\mbox{\hyperlink{3__1__queue_8c_aa78b6121b7586233293fb6cba5e19206}{xQueue}},\ \&pcToSendStirng,\ \mbox{\hyperlink{portmacro_8h_a72723ba1e4a85ca14f25c2b9e066613d}{portMAX\_DELAY}});}
\DoxyCodeLine{\mbox{\hyperlink{portable_8h_a7aaf584d8f548d7f03d6a46280c9e877}{pvPortMalloc}}()으로\ 동적\ 메모리\ 확보\ (50\ bytes)}
\DoxyCodeLine{snprintf()로\ 문자열\ 생성}

\end{DoxyCode}
 포인터만 큐에 전송 → 문자열 전체를 복사하지 않아 오버헤드 감소

🔹 Receiver\+Task 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{3__2__queue__queuingpointers_8c_a9d93014f8bf058a6984c15b1e4427184}{ReceiverTask}}(\textcolor{keywordtype}{void}\ *pvParameters)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *\ pcReceivingString;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{while}\ (1)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{queue_8h_ae8364d988c6f9b63c771cc2b3dfe5df9}{xQueueReceive}}(\mbox{\hyperlink{3__1__queue_8c_aa78b6121b7586233293fb6cba5e19206}{xQueue}},\ \&pcReceivingString,\ \mbox{\hyperlink{portmacro_8h_a72723ba1e4a85ca14f25c2b9e066613d}{portMAX\_DELAY}})\ ==\ \mbox{\hyperlink{projdefs_8h_a07848d3078849bd32353c69d30a479b3}{pdPASS}})\ \{\ \ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{vPortFree}}(pcReceivingString);\ \textcolor{comment}{//\ Free\ the\ buffer\ after\ use}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}\ }
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 큐에서 포인터 수신 문자열 사용 후 반드시 \doxylink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{v\+Port\+Free()}로 해제 → 해제하지 않으면 Memory Leak 발생\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md80}{}\doxysection{\texorpdfstring{4.\+Expected Output}{4.\+Expected Output}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md80}
시리얼 터미널에서 다음과 같은 출력이 반복됨\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Hello\ from\ SenderTask\ 0}
\DoxyCodeLine{Hello\ from\ SenderTask\ 1}
\DoxyCodeLine{Hello\ from\ SenderTask\ 2}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md81}{}\doxysection{\texorpdfstring{5.큐잉포인터 vs 기존 방식}{5.큐잉포인터 vs 기존 방식}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_23__2___q_u_e_u_e___q_u_e_u_i_n_g_p_o_i_n_t_e_r_s_autotoc_md81}
큐잉포인터 성능 오버헤드 높음 낮음 ( ) 메모리 관리 자동 수신 측에서 해제 필요

\begin{quote}
🔹비유 기존 방식\+: 편지를 복사해서 우체국(큐)에 넣는 것 복사본이 많으면 무겁고 느려요 포인터 방식\+: 편지를 가리키는 주소 메모만 보내는 것 → 우체국에서는 주소만 받고, 수신자가 해당 주소로 직접 찾아가서 열어보고, 읽고 나서 폐기 \end{quote}


➕ 추가 확장 포인터의 주소 자체를 또 큐에 보낼 수 있음 → "{}주소의 주소"{} 이는 이중 포인터 char \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}로 표현됨 (ex. 이중 구조체 관리 등)

⚠️ 주의사항 메모리 소유권(\+Ownership)\+: 할당과 해제의 책임 분명히 할당 Sender가 malloc, Receiver가 free 메모리 누수(\+Memory Leak)\+: \doxylink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{v\+Port\+Free()} 생략 시 발생 댕글링 포인터(\+Dangling Pointer)\+: 해제 후 접근 금지

✅ 결론 Free\+RTOS에서 포인터 기반 큐 전송이 성능을 어떻게 향상시키는지를 알 수 있습니다. 단, 정확한 메모리 관리가 필수이며, 포인터 전달은 항상 책임 있는 해제가 뒤따라야 함. 