\chapter{{\ttfamily eventhandlingqueue.\+c} 튜토리얼 }
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e}{}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e}\index{$<$tt$>$eventhandlingqueue.c$<$/tt$>$ 튜토리얼@{$<$tt$>$eventhandlingqueue.c$<$/tt$>$ 튜토리얼}}
\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md157}%
\Hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md157}%


이 문서는 {\ttfamily eventhandlingqueue.\+c} 예제 코드의 목적, 동작 방식 및 예상 결과에 대해 설명합니다.\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md158}{}\doxysection{\texorpdfstring{1. Objective (목표)}{1. Objective (목표)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md158}
이 예제의 주요 목표는 Free\+RTOS의 큐(\+Queue)를 활용한 여러 가지 이벤트를 한 곳에서 모아서 처리 패턴을 보여주고자함. (\texorpdfstring{$\ast$}{*} Free\+Rtos 동적 메모리 할당/해제 주의하여 볼것 )\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md159}{}\doxysection{\texorpdfstring{2.\+Code Description (코드 설명)}{2.\+Code Description (코드 설명)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md159}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md160}{}\doxysubsection{\texorpdfstring{{\ttfamily e\+IPEvent\+\_\+t} – 이벤트 종류 정하기}{{\ttfamily e\+IPEvent\+\_\+t} – 이벤트 종류 정하기}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md160}

\begin{DoxyItemize}
\item 시스템에서 발생할 수 있는 여러 가지 상황을 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}이벤트 이름으로 구분\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}합니다.
\begin{DoxyItemize}
\item {\ttfamily e\+Network\+Down\+Event} → 네트워크 끊김
\item {\ttfamily e\+Network\+Rx\+Event} → 데이터 도착
\item {\ttfamily e\+TCPAccept\+Event} → 새로운 연결 요청
\end{DoxyItemize}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md162}{}\doxysubsection{\texorpdfstring{{\ttfamily IPStack\+Event\+\_\+t} – 이벤트 한 개를 담는 구조}{{\ttfamily IPStack\+Event\+\_\+t} – 이벤트 한 개를 담는 구조}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md162}

\begin{DoxyItemize}
\item 하나의 이벤트는 다음 두 정보를 가집니다\+:
\begin{DoxyItemize}
\item {\ttfamily e\+Event\+Type}\+: 어떤 종류의 이벤트인지 ({\ttfamily \doxylink{7__2__eventhandlingqueue_8c_a15b56223e35c3a63499a99f33f1915b0}{e\+IPEvent\+\_\+t}} 값)
\item {\ttfamily pv\+Data}\+: 이벤트와 관련된 {\bfseries{추가 데이터(포인터)}} ~\newline
 → 예\+: 도착한 데이터, 소켓 정보 등 ~\newline
 → 데이터가 없으면 {\ttfamily NULL}
\end{DoxyItemize}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md164}{}\doxysubsection{\texorpdfstring{{\ttfamily v\+Send...} 함수들 – 이벤트를 만드는 함수}{{\ttfamily v\+Send...} 함수들 – 이벤트를 만드는 함수}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md164}

\begin{DoxyItemize}
\item 각각의 함수는 특정 이벤트를 만들어서 큐에 넣습니다.
\begin{DoxyItemize}
\item {\ttfamily \doxylink{7__2__eventhandlingqueue_8c_a327fa7c87d7f0b3b9ec3a39030c96e6a}{v\+Send\+Rx\+Data\+To\+The\+TCPTask()}} → 데이터 도착 이벤트 전송
\item {\ttfamily \doxylink{7__2__eventhandlingqueue_8c_a5f1f6a3a331ffcd084020b75f1d784ba}{v\+Send\+Accept\+Request\+To\+The\+TCPTask()}} → 소켓 연결 요청 이벤트 전송
\item {\ttfamily \doxylink{7__2__eventhandlingqueue_8c_a7f91de821e71a54305bf213dbc9bbc58}{v\+Send\+Network\+Down\+Event\+To\+The\+TCPTask()}} → 네트워크 끊김 알림
\end{DoxyItemize}
\item 이벤트에 데이터가 필요하면,
\begin{DoxyItemize}
\item 먼저 {\ttfamily \doxylink{portable_8h_a7aaf584d8f548d7f03d6a46280c9e877}{pv\+Port\+Malloc()}}으로 {\bfseries{동적 메모리 할당}}
\item 포인터를 {\ttfamily pv\+Data}에 넣어 큐에 함께 보냄
\end{DoxyItemize}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md166}{}\doxysubsection{\texorpdfstring{{\ttfamily v\+TCPTask(void \texorpdfstring{$\ast$}{*}pv\+Parameters)} – 이벤트를 처리하는 Task}{{\ttfamily v\+TCPTask(void \texorpdfstring{$\ast$}{*}pv\+Parameters)} – 이벤트를 처리하는 Task}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md166}

\begin{DoxyItemize}
\item 이 Task는 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}이벤트를 하나씩 받아서 처리\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}하는 중앙 관리자입니다.
\item 큐에서 이벤트를 꺼내고({\ttfamily \doxylink{queue_8h_ae8364d988c6f9b63c771cc2b3dfe5df9}{x\+Queue\+Receive()}}), ~\newline
 {\ttfamily switch}문으로 이벤트 종류를 확인해 각각 다르게 처리합니다.
\item 이벤트에 딸려온 데이터는 모두 사용 후 {\ttfamily \doxylink{portable_8h_a735cd3085bb7ba06ff8e47565bfd7016}{v\+Port\+Free()}}로 메모리 해제해야 함.
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md168}{}\doxysubsection{\texorpdfstring{{\ttfamily v\+Event\+Simulator\+Task(void \texorpdfstring{$\ast$}{*}pv\+Parameters)} – 더미 이벤트}{{\ttfamily v\+Event\+Simulator\+Task(void \texorpdfstring{$\ast$}{*}pv\+Parameters)} – 더미 이벤트}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md168}

\begin{DoxyItemize}
\item 실제 네트워크 대신 \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}가짜 이벤트\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}를 순서대로 만들어서 큐에 보냅니다.
\item 예\+:
\begin{DoxyItemize}
\item "{}데이터 도착"{} → "{}연결 요청"{} → "{}네트워크 끊김"{}
\end{DoxyItemize}
\item 테스트가 끝나면 자기 자신을 종료함 ({\ttfamily v\+Task\+Delete(\+NULL)})
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md170}{}\doxysubsubsection{\texorpdfstring{{\ttfamily main(void)} – 시작점}{{\ttfamily main(void)} – 시작점}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md170}

\begin{DoxyItemize}
\item {\ttfamily x\+Queue\+Create()}로 이벤트 큐({\ttfamily x\+Network\+Event\+Queue})를 만듭니다.
\item {\ttfamily v\+TCPTask}, {\ttfamily v\+Event\+Simulator\+Task} 두 개의 Task를 생성합니다.
\begin{DoxyItemize}
\item {\ttfamily v\+TCPTask}의 우선순위가 더 높음 (이벤트 먼저 처리하게 함)
\end{DoxyItemize}
\item {\ttfamily \doxylink{task_8h_aaf9dca1065c60abdeb309d56ab7293cb}{v\+Task\+Start\+Scheduler()}}로 Free\+RTOS 실행 시작!
\end{DoxyItemize}\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md171}{}\doxysection{\texorpdfstring{3. Expected Output (예상 결과)}{3. Expected Output (예상 결과)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md171}
{\ttfamily v\+Event\+Simulator\+Task}가 순차적으로 이벤트를 생성하여 큐에 넣으면, 우선순위가 더 높은 {\ttfamily v\+TCPTask}가 즉시 해당 이벤트를 수신하여 처리합니다. 모든 이벤트 처리가 완료된 후 {\ttfamily v\+Event\+Simulator\+Task}는 종료됩니다.\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md172}{}\doxysubsection{\texorpdfstring{3.\+1. 시리얼 출력 (Serial Output)}{3.\+1. 시리얼 출력 (Serial Output)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md172}

\begin{DoxyCode}{0}
\DoxyCodeLine{[TCP\ Task]\ Task\ started}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 0}
\DoxyCodeLine{}
\DoxyCodeLine{[SIM]\ 시뮬레이션\ 이벤트...}
\DoxyCodeLine{}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 1}
\DoxyCodeLine{[TCP\ Task]\ Event\ received:\ 1}
\DoxyCodeLine{Received\ data:\ Hello\ from\ network!}
\DoxyCodeLine{}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 1}
\DoxyCodeLine{[TCP\ Task]\ Event\ received:\ 2}
\DoxyCodeLine{Accepted\ socket\ id:\ 42}
\DoxyCodeLine{}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 1}
\DoxyCodeLine{[TCP\ Task]\ Event\ received:\ 0}
\DoxyCodeLine{Network\ down\ event\ received.}
\DoxyCodeLine{}
\DoxyCodeLine{[SIM]\ All\ events\ sent,\ task\ terminating}
\DoxyCodeLine{}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 0}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 0}
\DoxyCodeLine{[TCP\ Task]\ Queue\ waiting:\ 0}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md173}{}\doxysection{\texorpdfstring{4. 동작 원리 (Mermaid Diagram)}{4. 동작 원리 (Mermaid Diagram)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md173}

\begin{DoxyCode}{0}
\DoxyCodeLine{sequenceDiagram}
\DoxyCodeLine{\ \ \ \ participant\ SimulatorTask}
\DoxyCodeLine{\ \ \ \ participant\ EventQueue}
\DoxyCodeLine{\ \ \ \ participant\ TCPTask}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>TCPTask:\ 초기화\ 및\ 대기\ 시작}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ SimulatorTask-\/>>SimulatorTask:\ 1.\ Rx\ 이벤트\ 데이터\ 생성\ (메모리\ 할당)}
\DoxyCodeLine{\ \ \ \ SimulatorTask-\/>>EventQueue:\ 2.\ Rx\ 이벤트\ 전송}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>EventQueue:\ 3.\ Rx\ 이벤트\ 수신}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>TCPTask:\ 4.\ Rx\ 데이터\ 처리\ 및\ 메모리\ 해제}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ SimulatorTask-\/>>SimulatorTask:\ 5.\ Accept\ 이벤트\ 데이터\ 생성\ (메모리\ 할당)}
\DoxyCodeLine{\ \ \ \ SimulatorTask-\/>>EventQueue:\ 6.\ Accept\ 이벤트\ 전송}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>EventQueue:\ 7.\ Accept\ 이벤트\ 수신}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>TCPTask:\ 8.\ Accept\ 데이터\ 처리\ 및\ 메모리\ 해제}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ SimulatorTask-\/>>EventQueue:\ 9.\ Network\ Down\ 이벤트\ 전송\ (데이터\ 없음)}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>EventQueue:\ 10.\ Network\ Down\ 이벤트\ 수신}
\DoxyCodeLine{\ \ \ \ TCPTask-\/>>TCPTask:\ 11.\ Network\ Down\ 처리}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ SimulatorTask-\/>>SimulatorTask:\ 모든\ 이벤트\ 전송\ 후\ 스스로\ 종료}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md174}{}\doxysection{\texorpdfstring{5. 핵심 개념\+: 이벤트 기반 프로그래밍 (Event-\/\+Driven Programming)}{5. 핵심 개념\+: 이벤트 기반 프로그래밍 (Event-\/\+Driven Programming)}}\label{md__c_1_2_users_2_t_o_v_i_s_2test_2_test_rtos_2_doc_27__2___e_v_e_n_t_h_a_n_d_l_i_n_g_q_u_e_u_e_autotoc_md174}

\begin{DoxyItemize}
\item {\bfseries{중앙 집중 처리}}\+: 여러 소스(인터럽트, 다른 태스크 등)에서 발생하는 비동기적인 이벤트들을 하나의 큐로 모아, 단일 태스크에서 순서대로 처리함으로써 시스템의 동작을 단순화하고 예측 가능하게 만듭니다.
\item {\bfseries{디커플링(\+Decoupling)}}\+: 이벤트를 생성하는 측(\+Producer)과 처리하는 측(\+Consumer)이 큐를 통해 분리됩니다. 생산자는 이벤트 처리 방식에 대해 알 필요가 없고, 소비자도 이벤트 발생 시점에 대해 알 필요가 없습니다. 이는 코드의 모듈성과 재사용성을 높여줍니다.
\item {\bfseries{데이터 전달}}\+: {\ttfamily void\texorpdfstring{$\ast$}{*}} 포인터를 사용하여 어떤 종류의 데이터든 유연하게 전달할 수 있습니다. 단, 데이터를 수신한 측에서 정확한 타입으로 캐스팅하고, 동적으로 할당된 메모리를 해제하는 책임을 져야 합니다. 
\end{DoxyItemize}